<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mainboard Drag & Drop Trainer â€” Final Edge Safe</title>
<style>
  :root {
    --bg: #0f1b2d; --panel: #15233a; --accent: #23c483; --accent-red: #ff4d4f;
    --text: #eaf0ff; --muted: #a8b3c7;
    --zone: rgba(255, 153, 0, 0.22);
    --zone-border: rgba(255, 153, 0, 0.95);
    --zone-correct: rgba(35,196,131,0.18);
    --zone-wrong: rgba(255,77,79,0.18);
    --overlay: rgba(5,10,22,0.6);
  }
  * { box-sizing: border-box; }
  body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .app { display: grid; grid-template-columns: 360px 1fr; gap: 16px; height: 100vh; padding: 16px; }
  .sidebar { background: var(--panel); border-radius: 12px; padding: 16px; display: flex; flex-direction: column; overflow: auto; }
  .sidebar h2 { margin: 0 0 8px; font-size: 20px; }
  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 8px 0 12px; }
  .controls .wide { grid-column: 1 / -1; }
  .btn { appearance: none; border: none; border-radius: 10px; padding: 10px 12px; color: #0b1628; font-weight: 600; cursor: pointer; background: #eaf0ff; transition: transform 120ms ease, filter 120ms ease; }
  .btn.secondary { background: #cfe0ff; }
  .btn.warn { background: #ffd9d9; color: #5a1010; }
  .btn:active { transform: scale(0.98); filter: brightness(0.95); }

  .score { margin-top: 6px; padding: 10px; border-radius: 10px; background: #0c1730; color: var(--muted); display: flex; justify-content: space-between; align-items: center; }
  .score b { color: var(--text); }
  .list { display: grid; gap: 10px; margin-top: 12px; }

  .chip {
    user-select: none; touch-action: none; background: #0c1730; border: 2px solid #274163; color: var(--text);
    padding: 10px 12px; border-radius: 12px; font-weight: 700; box-shadow: 0 2px 0 #091026;
    width: 100%; text-align: left; position: relative; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; line-height: 1.1;
    transition: box-shadow 160ms ease, background 160ms ease, color 160ms ease, transform 140ms ease;
  }
  .chip.dragging { opacity: 0.96; transform: scale(1.04); }
  .chip.locked { background: #0e1c34; border-color: var(--accent); color: var(--accent); cursor: default; }

  .board { position: relative; background: var(--panel); border-radius: 12px; padding: 12px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
  .img-wrap { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
  #boardImg {
    display: block; max-width: 100%; max-height: calc(100vh - 64px); border-radius: 8px;
    object-fit: contain; background: #0c1730; z-index: 1;
  }

  .zones-holder { position: absolute; inset: 0; z-index: 2; }
  #zonesLayer { position: absolute; z-index: 3; pointer-events: none; }

  .zone {
    position: absolute;
    border: 2px dashed var(--zone-border);
    background: var(--zone);
    border-radius: 10px;
    pointer-events: auto;
    transition: background 140ms ease, border-color 140ms ease, transform 100ms ease, opacity 200ms ease, box-shadow 140ms ease;
    box-shadow: 0 0 0 1px rgba(255, 153, 0, 0.25);
  }
  .zone.highlight {
    background: rgba(255, 153, 0, 0.35);
    transform: scale(1.02);
    box-shadow: 0 0 0 2px rgba(255, 153, 0, 0.35);
  }
  .zone.correct { border-color: var(--accent); background: var(--zone-correct); }
  .zone.wrong   { border-color: var(--accent-red); background: var(--zone-wrong); }
  .zone.editable { cursor: move; outline: 1px solid rgba(255,255,255,0.4); }
  .zone .grip { position: absolute; right: -8px; bottom: -8px; width: 16px; height: 16px; background: #eaf0ff; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.35); display: none; }
  .zone.editable .grip { display: block; }

  .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 24px; max-width: 520px; background: #0c1730; border: 2px solid #274163; color: var(--text); border-radius: 12px; padding: 14px 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); z-index: 4100; }
  .hidden { display: none !important; }

  .overlay { position: fixed; inset: 0; background: var(--overlay); z-index: 4000; }
  #infoCard { position: fixed; z-index: 4100; left: 50%; top: 10%; transform: translateX(-50%); width: min(760px, 92vw); background: #0c1730; border: 2px solid #274163; color: var(--text); border-radius: 12px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
  #infoCard h3 { margin: 0 0 8px; }
  #infoCard .actions { display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end; }
  #infoBody ul { margin: 6px 0 0 18px; color: var(--muted); }

  #winCard { position: fixed; z-index: 4100; left: 50%; top: 10%; transform: translateX(-50%); width: min(760px, 92vw); background: #0c1730; border: 2px solid #274163; color: var(--text); border-radius: 12px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
  .pulse { animation: pulse 900ms ease-in-out 2; }
  @keyframes pulse { 0%{ transform:scale(1); box-shadow:0 0 0 rgba(35,196,131,0);} 50%{ transform:scale(1.02); box-shadow:0 0 24px rgba(35,196,131,0.35);} 100%{ transform:scale(1); box-shadow:0 0 0 rgba(35,196,131,0);} }

  #confetti { position: fixed; inset: 0; z-index: 4050; pointer-events: none; }
  @media (max-width: 880px) { .app { grid-template-columns: 1fr; } }
</style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h2>Mainboard Trainer</h2>
      <div class="controls">
        <button class="btn" id="shuffleBtn">Shuffle</button>
        <button class="btn" id="fullscreenBtn">Vollbild</button>
        <button class="btn secondary" id="toggleEditBtn">Zielâ€‘Editor</button>
        <button class="btn secondary" id="saveZonesBtn">Zonen speichern</button>
        <button class="btn secondary" id="exportZonesBtn">Zonen exportieren</button>
        <button class="btn secondary" id="importZonesBtn">Zonen importieren</button>
        <button class="btn secondary wide" id="toggleZonesBtn">Zonen an/aus</button>
        <button class="btn warn wide" id="resetBtn">ZurÃ¼cksetzen</button>
      </div>
      <div class="score">
        <div>Score: <b id="scoreVal">0</b>/<span id="scoreMax">0</span></div>
        <div id="progressText">Los gehtâ€™s!</div>
      </div>
      <div class="list" id="chipsList"></div>
    </aside>

    <main class="board">
      <div class="img-wrap" id="imgWrap">
        <img id="boardImg" width="1000" height="1000"
             src="https://asset.conrad.com/media10/isa/160267/c1/-/de/002842510PI00/image.jpg?x=1000&y=1000&format=jpg&ex=1000&ey=1000&align=center"
             alt="Mainboard Bild (ohne Beschriftung)" />
        <div class="zones-holder" id="zonesHolder">
          <div class="zones" id="zonesLayer"></div>
        </div>
      </div>
      <canvas id="confetti"></canvas>
      <div class="toast hidden" id="toast"></div>
    </main>
  </div>

  <div class="overlay hidden" id="overlay"></div>
  <div id="infoCard" class="hidden" role="dialog" aria-modal="true">
    <h3 id="infoTitle">Komponente</h3>
    <div id="infoBody">Beschreibung</div>
    <div class="actions"><button class="btn secondary" id="closeInfoBtn">Weiter</button></div>
  </div>

  <div id="winCard" class="hidden" role="dialog" aria-modal="true">
    <h3 id="winTitle" class="pulse">GlÃ¼ckwunsch! Alles korrekt ðŸŽ‰</h3>
    <p>Du hast alle Begriffe richtig zugeordnet. Stark!</p>
    <h4>Extraâ€‘Info: Speicherbus, Schnittstellen & Praxis</h4>
    <div id="extraInfo"></div>
    <div class="actions"><button class="btn" id="restartBtn">Neu starten</button></div>
  </div>

  <input type="file" class="hidden" id="zonesFileInput" accept="application/json" />

<script>
  const COMPONENTS = [
    { key: 'cpu_socket',    label: 'CPUâ€‘Sockel',
      info: `Der CPUâ€‘Sockel verbindet Prozessor und Mainboard mechanisch & elektrisch.
        <ul><li>AM4/AM5 (PGA) oder LGA1200/LGA1700 (LGA)</li><li>Retention + Pins/Kontakte</li><li>KompatibilitÃ¤t zu Chipsatz/KÃ¼hler beachten</li></ul>` },
    { key: 'ram_slots',     label: 'RAMâ€‘Slots (Arbeitsspeicher)',
      info: `SteckplÃ¤tze fÃ¼r DIMMs (DDRâ€‘Speicher).
        <ul><li>2â€“4 Slots; Dual/Quad Channel â†’ mehr Bandbreite</li><li>BestÃ¼ckung A2/B2 bevorzugt</li><li>DDRâ€‘Gen & XMP/EXPO je nach CPU/Board</li></ul>` },
    { key: 'pcie_x16',      label: 'PCIe x16â€‘Slot (Grafikkarte)',
      info: `Hauptsteckplatz fÃ¼r Grafikkarten/HBWâ€‘Karten.
        <ul><li>Lanes x16/x8; Gen3/4/5 Durchsatz</li><li>Verriegelungshebel</li><li>GPUâ€‘Strom Ã¼ber PCIeâ€‘Power</li></ul>` },
    { key: 'm2_slot',       label: 'M.2â€‘Slot (SSD)',
      info: `FÃ¼r NVMeâ€‘ oder SATAâ€‘M.2â€‘SSDs.
        <ul><li>Mâ€‘Key (NVMe), Bâ€‘Key (SATA)</li><li>Shared Lanes beeinflussen SATAâ€‘Ports</li><li>Heatsinks gegen Throttling</li></ul>` },
    { key: 'sata_ports',    label: 'SATAâ€‘AnschlÃ¼sse',
      info: `DatenanschlÃ¼sse fÃ¼r 2.5"/3.5" Laufwerke (SATA III 6 Gbit/s).
        <ul><li>Kabel verrasten</li><li>Teils Bandbreite mit M.2 geteilt</li><li>Separate SATAâ€‘Power nÃ¶tig</li></ul>` },
    { key: 'atx_24pin',     label: '24â€‘Pin ATXâ€‘Stromanschluss',
      info: `Hauptâ€‘Stromversorgung des Boards.
        <ul><li>3.3V/5V/12V Rails + Powerâ€‘Good</li><li>Sicher einrasten lassen</li></ul>` },
    { key: 'eps_8pin',      label: 'CPU Power Header',
      info: `ZusÃ¤tzliche 12Vâ€‘Versorgung fÃ¼r die CPUâ€‘VRMs (EPS).
        <ul>
          <li>Varianten: 4â€‘Pin, 8â€‘Pin, 4+4 (teilbar), teils 2Ã—8â€‘Pin bei Highâ€‘Endâ€‘Boards.</li>
          <li>Wichtig: Nicht mit PCIeâ€‘(GPU) 6+2â€‘Kabeln verwechseln â€“ anderes Pinout/Keying.</li>
          <li>Nutze die Kabel mit CPU/EPSâ€‘Kennzeichnung vom Netzteil fÃ¼r stabile Versorgung.</li>
        </ul>` },
    { key: 'vrm',           label: 'VRMs (Spannungswandler)',
      info: `Regeln die CPUâ€‘Versorgung prÃ¤zise.
        <ul><li>Mehr Phasen â†’ geringere WÃ¤rme/Last je Phase</li><li>MOSFETs, Spulen, Treiber; meist unter Heatsinks</li></ul>` },
    { key: 'cpu_fan_header',label: 'CPUâ€‘LÃ¼fterâ€‘Header',
      info: `Anschluss fÃ¼r CPUâ€‘KÃ¼hlerâ€‘LÃ¼fter (meist 4â€‘Pin PWM).
        <ul><li>BIOS/UEFI Steuerung (PWM/DC)</li><li>Kerbe beachten</li><li>CHA_FAN fÃ¼r GehÃ¤uselÃ¼fter</li></ul>` },
    { key: 'chipset',       label: 'Chipsatz (PCH) / KÃ¼hlkÃ¶rper',
      info: `I/Oâ€‘Hub: verwaltet PCIe, USB, SATA, weitere Peripherie.` },
    { key: 'cmos_battery',  label: 'CMOSâ€‘Batterie',
      info: `Pufferbatterie fÃ¼r RTC & BIOS/UEFIâ€‘Settings.
        <ul><li>Clearâ€‘CMOS setzt Defaults</li><li>CR2032 austauschbar</li></ul>` },
    { key: 'usb_header',    label: 'USBâ€‘Header (intern)',
      info: `Interne USBâ€‘Ports fÃ¼rs Frontpanel.
        <ul><li>USB 2.0 (9â€‘Pin), USB 3.x (19â€‘Pin), Frontâ€‘USBâ€‘C</li><li>Kerbe beachten</li></ul>` },
  ];

  let ZONES = [
    { key: 'cpu_socket',     x: 42,   y: 33,   w: 16,  h: 20 },
    { key: 'ram_slots',      x: 60.8, y: 18,   w: 8.7, h: 40 },
    { key: 'pcie_x16',       x: 34.5, y: 63.5, w: 31,  h: 7.2 },
    { key: 'm2_slot',        x: 43.5, y: 53.5, w: 25,  h: 6.2 },
    { key: 'sata_ports',     x: 72.5, y: 78.5, w: 20,  h: 7.5 },
    { key: 'atx_24pin',      x: 83.5, y: 34,   w: 6.2, h: 14.2 },
    { key: 'eps_8pin',       x: 5.2,  y: 6,    w: 8.5, h: 10.5 },
    { key: 'vrm',            x: 18.5, y: 14.5, w: 20,  h: 18 },
    { key: 'cpu_fan_header', x: 72.5, y: 6.5,  w: 12,  h: 10 },
    { key: 'chipset',        x: 57,   y: 71.5, w: 12,  h: 12 },
    { key: 'cmos_battery',   x: 52,   y: 66.8, w: 8,   h: 10 },
    { key: 'usb_header',     x: 46,   y: 90,   w: 22,  h: 8 },
  ];

  const EXTRA_INFO = `
    <ul>
      <li><b>PCIe:</b> Erweiterungsbus fÃ¼r GPUs/SSDs. Jede Gen (3/4/5) erhÃ¶ht Bandbreite/Lane; x16 fÃ¼r GPU, M.2 meist x4.</li>
      <li><b>M.2 / NVMe:</b> NVMe nutzt PCIe direkt (x4). Deutlich schneller als SATA; Keying (Mâ€‘Key) und mÃ¶gliche Laneâ€‘Teilung beachten.</li>
      <li><b>SATA:</b> Stabil fÃ¼r HDDs/klassische SSDs (6â€¯Gbit/s). FÃ¼r Massenspeicher top, aber langsamer als NVMe.</li>
      <li><b>USBâ€‘Header (intern):</b> Frontpanelâ€‘Ports; USB 2.0/3.x/USBâ€‘C mit unterschiedlichen Steckern und Leistungen.</li>
      <li><b>DMI/Chipsatzâ€‘Link:</b> Bindeglied zwischen CPU und PCH. Gute Laneâ€‘Verteilung vermeidet EngpÃ¤sse bei paralleler I/O.</li>
      <li><b>Praxis:</b> GPU in den obersten x16â€‘Slot; NVMe in Genâ€‘aktuellen M.2â€‘Slots; SATA fÃ¼r groÃŸe DatengrÃ¤ber; Frontâ€‘USB am passenden Header.</li>
    </ul>
  `;

  const state = { score: 0, total: COMPONENTS.length, placements: new Map(), showZones: true, editing: false, imageKey: 'conrad-002842510PI00' };

  // DOM
  const imgWrap = document.getElementById('imgWrap');
  const boardImg = document.getElementById('boardImg');
  const zonesHolder = document.getElementById('zonesHolder');
  const zonesLayer = document.getElementById('zonesLayer');
  const chipsList = document.getElementById('chipsList');
  const scoreVal = document.getElementById('scoreVal');
  const scoreMax = document.getElementById('scoreMax');
  const progressText = document.getElementById('progressText');
  const toast = document.getElementById('toast');
  const overlay = document.getElementById('overlay');
  const infoCard = document.getElementById('infoCard');
  const infoTitle = document.getElementById('infoTitle');
  const infoBody = document.getElementById('infoBody');
  const winCard = document.getElementById('winCard');
  const winTitle = document.getElementById('winTitle');
  const extraInfo = document.getElementById('extraInfo');

  const shuffleBtn = document.getElementById('shuffleBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const toggleZonesBtn = document.getElementById('toggleZonesBtn');
  const toggleEditBtn = document.getElementById('toggleEditBtn');
  const saveZonesBtn = document.getElementById('saveZonesBtn');
  const exportZonesBtn = document.getElementById('exportZonesBtn');
  const importZonesBtn = document.getElementById('importZonesBtn');
  const zonesFileInput = document.getElementById('zonesFileInput');
  const resetBtn = document.getElementById('resetBtn');
  const closeInfoBtn = document.getElementById('closeInfoBtn');
  const restartBtn = document.getElementById('restartBtn');

  const confettiCanvas = document.getElementById('confetti');
  const ctx = confettiCanvas.getContext('2d');

  let overlayMetrics = { left: 0, top: 0, width: 0, height: 0 };

  async function ensureImageReady() {
    if (boardImg.complete && boardImg.naturalWidth > 0) return;
    try { await boardImg.decode(); } catch {}
    await new Promise(res => boardImg.addEventListener('load', res, { once: true }));
  }

  const ro = new ResizeObserver(() => {
    requestAnimationFrame(() => { syncOverlay(); renderZones(); });
  });
  ro.observe(boardImg);

  (async function init() {
    scoreMax.textContent = state.total;
    buildChips();
    await ensureImageReady();
    requestAnimationFrame(() => { syncOverlay(); renderZones(); });
    updateScore();
    resizeCanvas();
    loadSavedZones();
  })();

  window.addEventListener('resize', () => {
    requestAnimationFrame(() => {
      syncOverlay(); renderZones();
      chipsList.querySelectorAll('.chip.locked').forEach(ch => {
        const zone = zonesLayer.querySelector(`.zone[data-key="${ch.dataset.key}"]`);
        if (zone) snapChipToZone(ch, zone, true);
      });
      resizeCanvas();
    });
  });

  function buildChips() {
    chipsList.innerHTML = '';
    COMPONENTS.forEach(comp => {
      const chip = document.createElement('button');
      chip.className = 'chip'; chip.textContent = comp.label; chip.title = comp.label; chip.dataset.key = comp.key;
      chipsList.appendChild(chip); makeDraggable(chip);
    });
  }

  function syncOverlay() {
    const wrapRect = imgWrap.getBoundingClientRect();
    const imgRects = boardImg.getClientRects();
    const imgRect = imgRects.length ? imgRects[0] : boardImg.getBoundingClientRect();
    if (!imgRect.width || !imgRect.height) return;

    const left = Math.round(imgRect.left - wrapRect.left);
    const top  = Math.round(imgRect.top  - wrapRect.top);
    const width  = Math.round(imgRect.width);
    const height = Math.round(imgRect.height);

    overlayMetrics = { left, top, width, height };

    zonesLayer.style.left = left + 'px';
    zonesLayer.style.top  = top  + 'px';
    zonesLayer.style.width  = width  + 'px';
    zonesLayer.style.height = height + 'px';

    zonesHolder.style.pointerEvents = state.editing ? 'auto' : 'none';
    zonesLayer.style.pointerEvents  = state.editing ? 'auto' : 'none';
  }

  function renderZones() {
    zonesLayer.innerHTML = '';
    const W = overlayMetrics.width || zonesLayer.getBoundingClientRect().width;
    const H = overlayMetrics.height || zonesLayer.getBoundingClientRect().height;
    if (!W || !H) return;

    ZONES.forEach(z => {
      const el = document.createElement('div');
      el.className = 'zone'; el.dataset.key = z.key;
      el.style.left   = (W * Number(z.x) / 100) + 'px';
      el.style.top    = (H * Number(z.y) / 100) + 'px';
      el.style.width  = (W * Number(z.w) / 100) + 'px';
      el.style.height = (H * Number(z.h) / 100) + 'px';
      zonesLayer.appendChild(el);

      if (state.editing) {
        el.classList.add('editable');
        const grip = document.createElement('div'); grip.className = 'grip'; el.appendChild(grip);
        enableZoneDragAndResize(el, grip);
      }
    });
    setZonesVisible(state.showZones);
  }

  function setZonesVisible(show) {
    state.showZones = show;
    zonesLayer.querySelectorAll('.zone').forEach(z => z.style.opacity = show ? '1' : '0');
    toggleZonesBtn.textContent = show ? 'Zonen ausblenden' : 'Zonen einblenden';
  }

  function showToast(msg) { toast.textContent = msg; toast.classList.remove('hidden'); setTimeout(() => toast.classList.add('hidden'), 2000); }
  function updateScore() { scoreVal.textContent = state.score; const remain = state.total - state.score; progressText.textContent = remain > 0 ? `Noch ${remain} offen` : `Fertig ðŸŽ¯`; }

  // Drag/Drop Chips â€” Breite auf TextlÃ¤nge begrenzen
  function makeDraggable(el) {
    let dragging = false, startX = 0, startY = 0, originRect = null;
    el.addEventListener('pointerdown', (ev) => {
      if (el.classList.contains('locked')) return;
      dragging = true;
      el.setPointerCapture(ev.pointerId);
      el.classList.add('dragging');

      el.style.width = 'auto';
      el.style.display = 'inline-block';
      el.style.whiteSpace = 'nowrap';
      const naturalWidth = Math.ceil(el.scrollWidth);
      el.style.width = naturalWidth + 'px';

      originRect = el.getBoundingClientRect();
      startX = ev.clientX - originRect.left;
      startY = ev.clientY - originRect.top;

      el.style.position = 'fixed';
      el.style.zIndex = '999';
      moveChip(el, ev.clientX - startX, ev.clientY - startY);
    });

    el.addEventListener('pointermove', (ev) => {
      if (!dragging) return;
      moveChip(el, ev.clientX - startX, ev.clientY - startY);
      highlightZones(ev.clientX, ev.clientY);
    });

    el.addEventListener('pointerup', (ev) => {
      if (!dragging) return;
      dragging = false;
      el.classList.remove('dragging');
      const target = getHitZone(ev.clientX, ev.clientY);
      zonesLayer.querySelectorAll('.zone').forEach(z => z.classList.remove('highlight'));
      if (!target) { bounceBack(el); return; }

      if (target.dataset.key === el.dataset.key) {
        target.classList.add('correct');
        el.classList.add('locked');
        snapChipToZone(el, target, true);
        state.placements.set(el.dataset.key, target);
        state.score += 1;
        updateScore();
        const comp = COMPONENTS.find(c => c.key === el.dataset.key);
        openInfoFromZone(target, comp);
        checkWin();
      } else {
        flashWrong(target);
        bounceBack(el);
      }
    });
  }

  function moveChip(el, x, y) { el.style.left = x + 'px'; el.style.top = y + 'px'; }

  function bounceBack(el) {
    el.style.transition = 'transform 180ms ease';
    el.style.transform = 'translateY(-6px)';
    setTimeout(() => {
      el.style.transform = el.style.transition = '';
      el.style.width = ''; el.style.display = ''; el.style.whiteSpace = '';
      el.style.position = el.style.left = el.style.top = el.style.zIndex = '';
      chipsList.appendChild(el);
    }, 180);
    showToast('âŒ Falsch â€“ versuchâ€™s nochmal');
  }

  function snapChipToZone(el, zone, adapt=false) {
    const zr = zone.getBoundingClientRect();
    el.style.position = 'fixed';
    el.style.left = (zr.left + 6) + 'px';
    el.style.top  = (zr.top + 6) + 'px';
    el.style.zIndex = '50';
    if (adapt) adaptChipToZone(el, zone);
    el.animate([{ transform: 'scale(0.98)' }, { transform: 'scale(1)' }], { duration: 140 });
    showToast('âœ… Richtig!');
  }

  function adaptChipToZone(chip, zone) {
    const zr = zone.getBoundingClientRect();
    const pad = 8;
    const targetW = Math.max(zr.width - pad*2, 60);
    const targetH = Math.max(zr.height - pad*2, 28);
    chip.style.width  = targetW + 'px';
    chip.style.height = targetH + 'px';
    chip.style.whiteSpace = 'normal';
    chip.style.wordBreak = 'break-word';
    chip.style.hyphens = 'auto';
    chip.style.lineHeight = '1.1';
    let fontSize = 18;
    chip.style.fontSize = fontSize + 'px';
    const fits = () => chip.scrollWidth <= chip.clientWidth && chip.scrollHeight <= chip.clientHeight;
    while (!fits() && fontSize > 10) { fontSize -= 1; chip.style.fontSize = fontSize + 'px'; }
  }

  function highlightZones(cx, cy) {
    const target = getHitZone(cx, cy);
    zonesLayer.querySelectorAll('.zone').forEach(z => z.classList.remove('highlight'));
    if (target) target.classList.add('highlight');
  }

  function getHitZone(cx, cy) {
    return Array.from(zonesLayer.querySelectorAll('.zone'))
      .find(z => { const r = z.getBoundingClientRect(); return (cx >= r.left && cx <= r.right && cy >= r.top && cy <= r.bottom); }) || null;
  }
  function flashWrong(zone) { zone.classList.add('wrong'); setTimeout(() => zone.classList.remove('wrong'), 300); }

  function enableZoneDragAndResize(zoneEl, grip) {
    let dragging = false, resizing = false, offsetX = 0, offsetY = 0, startW = 0, startH = 0, startX = 0, startY = 0;
    zoneEl.addEventListener('pointerdown', (ev) => {
      if (!state.editing || ev.target === grip) return;
      dragging = true; zoneEl.setPointerCapture(ev.pointerId);
      const r = zoneEl.getBoundingClientRect(); offsetX = ev.clientX - r.left; offsetY = ev.clientY - r.top;
    });
    grip.addEventListener('pointerdown', (ev) => {
      if (!state.editing) return;
      resizing = true; zoneEl.setPointerCapture(ev.pointerId);
      const r = zoneEl.getBoundingClientRect(); startW = r.width; startH = r.height; startX = ev.clientX; startY = ev.clientY;
    });
    zoneEl.addEventListener('pointermove', (ev) => {
      if (!state.editing) return;
      const layerRect = zonesLayer.getBoundingClientRect();
      if (dragging) {
        const nx = Math.min(Math.max(ev.clientX - layerRect.left - offsetX, 0), layerRect.width - zoneEl.offsetWidth);
        const ny = Math.min(Math.max(ev.clientY - layerRect.top  - offsetY, 0), layerRect.height - zoneEl.offsetHeight);
        zoneEl.style.left = nx + 'px'; zoneEl.style.top = ny + 'px';
      }
      if (resizing) {
        const newW = Math.min(Math.max(startW + (ev.clientX - startX), 30), layerRect.width - zoneEl.offsetLeft);
        const newH = Math.min(Math.max(startH + (ev.clientY - startY), 24), layerRect.height - (zoneEl.offsetTop - layerRect.top));
        zoneEl.style.width = newW + 'px'; zoneEl.style.height = newH + 'px';
      }
    });
    zoneEl.addEventListener('pointerup', () => { dragging = false; resizing = false; });
    zoneEl.addEventListener('pointercancel', () => { dragging = false; resizing = false; });
  }

  function openInfoFromZone(zoneEl, comp) {
    infoTitle.textContent = comp.label; infoBody.innerHTML = comp.info;
    overlay.classList.remove('hidden'); infoCard.classList.remove('hidden');
    const from = zoneEl.getBoundingClientRect(); const to = infoCard.getBoundingClientRect();
    const deltaX = from.left + from.width/2 - (to.left + to.width/2);
    const deltaY = from.top  + from.height/2 - (to.top  + to.height/2);
    const scaleX = from.width / to.width; const scaleY = from.height / to.height;
    infoCard.animate([{ transform:`translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`, opacity:0.6 }, { transform:'translate(0,0) scale(1,1)', opacity:1 }], { duration:520, easing:'cubic-bezier(0.22, 1, 0.36, 1)' });
  }
  closeInfoBtn.addEventListener('click', () => { overlay.classList.add('hidden'); infoCard.classList.add('hidden'); });

  function checkWin() {
    if (state.score >= state.total) {
      extraInfo.innerHTML = EXTRA_INFO; runConfetti(6000);
      overlay.classList.remove('hidden'); winCard.classList.remove('hidden');
      winTitle.classList.remove('pulse'); void winTitle.offsetWidth; winTitle.classList.add('pulse');
    }
  }
  restartBtn.addEventListener('click', () => { overlay.classList.add('hidden'); winCard.classList.add('hidden'); resetAll(); });

  toggleEditBtn.addEventListener('click', () => {
    state.editing = !state.editing;
    toggleEditBtn.textContent = state.editing ? 'Editor aktiv (Speichern)' : 'Zielâ€‘Editor';
    requestAnimationFrame(() => { syncOverlay(); renderZones(); });
    showToast(state.editing ? 'Editor aktiv â€“ Zonen verschiebbar & resizebar' : 'Editor beendet â€“ gespeichert');
    if (!state.editing) saveZones();
  });
  saveZonesBtn.addEventListener('click', saveZones);
  toggleZonesBtn.addEventListener('click', () => setZonesVisible(!state.showZones));
  resetBtn.addEventListener('click', resetAll);
  shuffleBtn.addEventListener('click', () => shuffleList(chipsList));
  fullscreenBtn.addEventListener('click', async () => {
    const el = document.documentElement;
    try { if (!document.fullscreenElement) await el.requestFullscreen(); else await document.exitFullscreen(); }
    catch (e) { showToast('Vollbild nicht mÃ¶glich'); }
  });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { overlay.classList.add('hidden'); infoCard.classList.add('hidden'); winCard.classList.add('hidden'); } });
  overlay.addEventListener('click', () => { overlay.classList.add('hidden'); infoCard.classList.add('hidden'); winCard.classList.add('hidden'); });

  // Export
  exportZonesBtn.addEventListener('click', () => {
    const blob = new Blob([JSON.stringify({ imageKey: state.imageKey, zones: ZONES }, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a');
    a.href = url; a.download = `zones_${state.imageKey}.json`; a.click(); URL.revokeObjectURL(url);
    showToast('Zonen exportiert (JSON)');
  });

  // Import â€” FIXED: anwenden, entsperren, rAF + ensureImageReady
  importZonesBtn.addEventListener('click', () => zonesFileInput.click());
  zonesFileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      const nextZones = Array.isArray(data) ? data : data.zones;

      if (!nextZones || !nextZones.length) { showToast('UngÃ¼ltige Zonenâ€‘Datei'); e.target.value=''; return; }

      // Werte normalisieren
      ZONES = nextZones.map(z => ({
        key: z.key,
        x: Number(z.x),
        y: Number(z.y),
        w: Number(z.w),
        h: Number(z.h)
      }));

      // Speicher aktualisieren (aktueller imageKey bleibt erhalten)
      localStorage.setItem('zones-' + state.imageKey, JSON.stringify(ZONES));

      // Chips entsperren und Score resetten, damit neue Positionen klar erkennbar sind
      state.score = 0; state.placements.clear(); updateScore();
      chipsList.querySelectorAll('.chip').forEach(ch => {
        ch.classList.remove('locked');
        ch.style.transform = ch.style.position = ch.style.left = ch.style.top = ch.style.zIndex = '';
        ch.style.width = ch.style.height = ch.style.fontSize = '';
        ch.style.display = ''; ch.style.whiteSpace = '';
        chipsList.appendChild(ch);
      });

      // Sicher neu rendern (Edge-safe)
      await ensureImageReady();
      requestAnimationFrame(() => { syncOverlay(); renderZones(); });

      showToast('Zonen importiert und angewendet');
    } catch (err) {
      console.error('Import error:', err);
      showToast('Import fehlgeschlagen');
    } finally {
      // Damit das gleiche File erneut importiert werden kann
      e.target.value = '';
    }
  });

  function saveZones() {
    const layerRect = zonesLayer.getBoundingClientRect();
    const next = [];
    zonesLayer.querySelectorAll('.zone').forEach(z => {
      const r = z.getBoundingClientRect();
      const xPct = ((r.left - layerRect.left) / layerRect.width) * 100;
      const yPct = ((r.top  - layerRect.top  ) / layerRect.height) * 100;
      const wPct = (r.width  / layerRect.width) * 100;
      const hPct = (r.height / layerRect.height) * 100;
      next.push({ key: z.dataset.key, x: xPct, y: yPct, w: wPct, h: hPct });
    });
    ZONES = next; localStorage.setItem('zones-' + state.imageKey, JSON.stringify(ZONES));
    showToast('Zonen gespeichert');
  }

  function loadSavedZones() {
    const raw = localStorage.getItem('zones-' + state.imageKey);
    if (raw) {
      try {
        ZONES = JSON.parse(raw);
        requestAnimationFrame(() => { renderZones(); });
        showToast('Gespeicherte Zonen geladen');
        return true;
      } catch {}
    }
    return false;
  }

  const rng = (n) => Math.floor(Math.random() * n);
  function shuffleList(parent) {
    const nodes = Array.from(parent.children);
    for (let i = nodes.length - 1; i > 0; i--) {
      const j = rng(i + 1);
      parent.insertBefore(nodes[j], nodes[i]);
      [nodes[i], nodes[j]] = [nodes[j], nodes[i]];
    }
  }
  function resetAll() {
    state.score = 0; state.placements.clear(); updateScore();
    chipsList.querySelectorAll('.chip').forEach(ch => {
      ch.classList.remove('locked');
      ch.style.transform = ch.style.position = ch.style.left = ch.style.top = ch.style.zIndex = '';
      ch.style.width = ch.style.height = ch.style.fontSize = '';
      ch.style.display = ''; ch.style.whiteSpace = '';
      chipsList.appendChild(ch);
    });
    zonesLayer.querySelectorAll('.zone').forEach(z => z.classList.remove('correct','wrong'));
    showToast('ZurÃ¼ckgesetzt');
  }

  function resizeCanvas() { confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; }
  function runConfetti(ms = 5000) {
    const particles = []; const colors = ['#23c483','#ffd166','#06d6a0','#118ab2','#ef476f','#a8b3c7']; const count = 220;
    for (let i = 0; i < count; i++)
      particles.push({ x: Math.random()*confettiCanvas.width, y: -10 - Math.random()*200, vx: -1 + Math.random()*2, vy: 2 + Math.random()*3, size: 3 + Math.random()*6, color: colors[Math.floor(Math.random()*colors.length)], angle: Math.random()*Math.PI*2, spin: (-0.1 + Math.random()*0.2) });
    let start = null;
    function step(ts) {
      if (!start) start = ts; const dt = (ts - start);
      ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
      particles.forEach(p => {
        p.x+=p.vx; p.y+=p.vy; p.angle+=p.spin;
        ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.angle);
        ctx.fillStyle=p.color; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size*1.4);
        ctx.restore();
      });
      if (dt < ms) requestAnimationFrame(step); else ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
    }
    requestAnimationFrame(step);
  }
  // Auto-load zones JSON hosted next to this HTML
  async function autoLoadHostedZones() {
    try {
      // Encode space in file name; cache-bust so updates show immediately
      const res = await fetch('Final%20Zones2.json?cb=' + Date.now(), { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);

      const data = await res.json();
      const nextZones = Array.isArray(data) ? data : data.zones;
      if (!nextZones || !nextZones.length) throw new Error('Invalid zones payload');

      // Apply and normalize values
      window.ZONES = nextZones.map(z => ({
        key: z.key,
        x: Number(z.x),
        y: Number(z.y),
        w: Number(z.w),
        h: Number(z.h)
      }));

      // Optional: adopt imageKey from file
      if (data.imageKey) window.state.imageKey = data.imageKey;

      // Persist and render (Edge-safe)
      localStorage.setItem('zones-' + window.state.imageKey, JSON.stringify(window.ZONES));
      if (typeof ensureImageReady === 'function') await ensureImageReady();
      requestAnimationFrame(() => { 
        if (typeof syncOverlay === 'function') syncOverlay();
        if (typeof renderZones === 'function') renderZones();
      });

      if (typeof showToast === 'function') showToast('Zonen automatisch geladen');
      return true;
    } catch (e) {
      console.debug('Auto-Load Zonen fehlgeschlagen:', e);
      return false;
    }
  }

  // Run once at startup: try hosted JSON first, else fall back
  (async function () {
    const ok = await autoLoadHostedZones();
    if (!ok) {
      if (typeof loadSavedZones === 'function') loadSavedZones();
      requestAnimationFrame(() => { 
        if (typeof syncOverlay === 'function') syncOverlay();
        if (typeof renderZones === 'function') renderZones();
      });
    }
  })();
</script>
</body>
</html>



